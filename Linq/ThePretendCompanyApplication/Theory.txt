






















--------------------------------------------------
hi and welcome to the first part of a video series on link this video is also the first part of the seventh tutorial in an advanced c-sharp course later in this tutorial we'll look at a code example to help with our understanding of link but let's first answer the question what is link link stands for language integrated query link is defined in the microsoft docs as the name for a set of technologies based on the integration of query capabilities directly into the c-sharp language link was originally released as a major
part of net framework 3.5 in 2007 please consider subscribing for more content on advanced c-sharp concepts and much more and please ring the bell so that you'll be notified of future content released from this channel here is a paragraph from the microsoft docs which provides an excellent overview of what link is [Music] integrated query link is the name for a set of technologies based on the integration of query capabilities directly into the c-sharp language traditionally queries against data are expressed as simple strings without
type checking at compile time or intellisense support furthermore you have to learn a different query language for each type of data source sql databases xml documents various web services and so on with link a query is a first class language construct just like classes methods events you write queries against strongly typed collections of objects by using language keywords and familiar operators the link family of technologies provides a consistent query experience for objects link to objects relational databases
linked to sql and xml link to xml note that you can write link queries in c sharp for sql server databases xml documents ado.net datasets and any collection of objects that support the ienumerable interface or the generic ienumerable interface so for example you can perform link queries against collection types like an array generic list generic dictionary generic q generic stack etc basically any collection type that implements the ienumerable interface or the generic innumerable interface link support is also provided by third
parties for many web services and other database implementations you can create custom providers using i queryable custom providers will not be discussed in detail in this video series if you would like to learn more about implementing your own custom provider please navigate to this url [Music] in this video series we'll primarily focus on link to objects and link to entities link to entities provides language integrated query link support that enables developers to write queries against the entity framework conceptual model
using either visual basic or visual c-sharp so entity framework core is a modern object database mapper for net it supports link queries change tracking updates and schema migrations entity framework core or ef core can be used to work with many databases including sql databases on-premises and azure sqlite mysql postgres and azure cosmos db in this video series we won't look at link to data set or link to xml please navigate to this url for more information on linked dataset and please navigate to this url for more
information on link2xml as always all links mentioned in the videos created by this channel are available below in the description to get started with link in this video we'll focus on link to objects so that we can first get a basic idea of what the implementation of link looks like in code and how it can be used for querying c-sharp collections before we create a code example i want to mention that in the c-sharp courses created for this channel both the beginner's course and the advanced course there's a push towards
cross-platform development this is without a doubt the future of development the.net core runtime enables cross-platform development and cross-platform deployment for net developers the.net 5 runtime the official release is expected in november 2020 will further eliminate barriers to cross-platform development for net developers if you haven't seen the second part of this advanced course please do so to gain a basic understanding of net 5.
so in the spirit of cross-platform development i've decided to demonstrate this code example on my mac platform using visual studio 2019 for mac community edition if you have a mac platform and wish to follow along on your mac and you don't yet have visual studio installed you are able to download and install visual studio community edition 2019 free of charge from this location all links mentioned in this video are available below in the description if you are using a windows os please don't let the fact that i'm using a mac
platform put you off following along with this tutorial in terms of the code example that we'll create in this video the coding experience using visual studio for mac is almost exactly the same as the coding experience using visual studio for windows so this should not be a barrier for a learner to follow along with this demonstration if you haven't yet installed visual studio 2019 on your windows platform please view a video created by this channel which provides a guide to installing visual studio 2019
community edition free of charge so firstly let's create a net core console application let's name this project the pretend company application before we write calling client code in the main method we are going to add two standard library projects let's first add a standard library project named tcp data let's then add another standard library project named tcp extensions so let's now go to our project that we
named tcp data let's delete the class that has been automatically generated for the tcp data project let's add a new class named employee let's add six auto implemented properties to the employee class id as int first name as string last name as string annual salary as decimal is manager as boolean and lastly department id as int let's add another class to the tcp data project let's name this class department let's add three auto implemented properties to our department class id as int short name as string
and long name as string let's add a class named data to our tcp data project let's make this class a static class so let's add two public static methods to the data class let's first create a static method named get employees which returns a generic list strongly typed as employee let's ensure that we include the appropriate using directive for the use of generic list objects at the top of our code editor so let's include a using directive to the system.collections.
generic namespace like this let's write the code to add some made-up employee records to a generic list that is strongly typed with the user-defined type employee you uh
uh let's write code to return the list of employee records to the calling client code let's add another static method and let's name this method get departments this method also returns a generic list
object but this generic list object is strongly typed as department let's write the codes to add some made-up department records to a generic list that is strongly typed with the user-defined type department let's write code to return the list of department records to the calling client code so as you can see the get employees method returns a list of employee records and the getdepartments method returns a list of department records so in order to gain an understanding for
how link works let's ensure that we properly understand two fundamental concepts i.e the concept of extension methods and the concept of lambda expressions so let's go to our tcp extensions project let's delete the class that was auto generated by visual studio when we created the project let's add a class named extension so in order for our extension method to work we must make the extension class a static class so we are going to add a method named filter the idea here is we want a way where we
can extend the functionality of any generic list that is strongly typed with any c c-sharp data type including user-defined types we can achieve this by creating our own extension method so for example if we want to filter employee records by criteria that we are able to specify through a lambda expression on a generic list that is strongly typed as employee we can do this through our filter extension method this will be demonstrated in the calling client code in a bit so how do we create our own custom extension method
so i'll first create the method signature for the filter extension method first notice that our method like the class in which it resides must be static which is achieved by including the static keyword in the relevant extension methods method signature so if we look at the first parameter in the filter methods method signature we can see that we are using for this keyword preceding the data type of the first parameter which is a generic list of type t the this keyword in this context indicates to the compiler
that the relevant method can be called on an object of the data type of the relevant parameter in this example that is a generic list which contains a type t placeholder as we know from the video series on c-sharp generics a developer is able to pass a data type argument to the parameter of type t which can be any c-sharp data type including user-defined types the data type specified will be chosen depending on the requirement that needs to be met by the calling client code we'll demonstrate the consumption of
client-side code for the filter extension method in a bit so let's look at the second parameter which is of the delegate type func for more information about the funk delegate type please view a video created by this channel on this topic a link to this video is available below in the description the first dates type parameter passed to the funk delegate type represents the first data type of the first parameter of the method referenced by the relevant argument passed into this parameter the last parameter in the func delegate type definition is
the return type of the method referenced by the argument passed into this parameter so the first parameter passed into the func delegate is of type t and the second parameter is of type bull note that a predicate delegates type can be used to define method definitions for a method that returns a boolean value so we could replace the func delegate type with a predicate delegate type let's use the func delegate type but please note that we could also achieve the same end using the predicate delegate type and as you can see this method will
return a list of objects of type t to the calling client code so let's complete the logic for this method let's implement the code for the filter method so basically we are looping through the list on which the filter extension method is invoked we are then adding its elements to a new generic list also of type t whether or not we add this list item is based on the boolean value returned by a method reference passed into the second parameter of the filter method so the relevant method reference is stored in the argument passed to the
parameter named funk as you can see the method that the variable named func references accepts an argument of type t so we are passing in each item stored in the calling clients list which is the generic list on which calling client code will invoke the filter extension method if the method that the func variable references returns true the item stored in the iterated list is added to a new list we then return the new list containing the filtered items to the calling client code so this effectively means that the
calling client code is able to use our filter method to filter any generic list based on a method created in the calling client code this method created in the calling client code will contain the logic for filtering the relevant generic list a reference to this method will be passed into the second parameter of our filter extension method and must adhere to the method definition represented in the second parameter of the filter method i.
e the definition represented in the func delegate type so we are now going to implement the calling client code and you'll see that the method passed into the second parameter of our filter method will be an anonymous method i.e a method that is not named this method will be expressed as a lambda expression we'll now see how we are able to filter a generic list using our filter extension method through calling client code in the main method of our application right so let's go to the dot net core console project and write the calling client code
in our main method firstly let's reference our two standard library projects from our net core console project so let's right click the dependencies node in the net core console project and check tcp data as well as tcp extensions so let's test our filter extension method in a bit i'll further elucidate why it is important to understand extension methods and lambda expressions with regards to link through the magic of how extension methods work in c-sharp we should be able to call the extension method on any
generic list object so let's define a generic list that is strongly typed as the employee user defines type so we have a red squiggly line under our generic list type definition so to fix this we need to include a directive at the top of our code to the system.collections.generic namespace we can see that there is a red squiggly line under the code that strongly types our generic list as the user-defined type employee so to fix this let's include a directive at the top of our code to the tcp data namespace
great so through the magic of extension methods we should see the filter method appear in the intellisense drop-down list when we add a dot after the employee list variable okay so why are we not seeing the filter method appearing in our intellisense drop down list the reason for this is because we haven't included a using directive to the appropriate namespace so let's include a using directive at the top of our code to the appropriate namespace ie tcp extensions so now if we add a dot immediately after the employee list
variable the magic of extension methods is revealed to us and we can see our filter method in the intellisense drop-down list so note that when we open brackets to pass in appropriate arguments to the filter method we see that only one parameter is required this parameter was the second parameter we defined for this method so why is the first parameter in the filter method not listed when we open the brackets in this way well the answer to that question is this is how extension methods work the consumer of the code ie the calling
client code does not need to pass in the first parameter this is automatically handled behind the scenes as it were by default the first parameter is the object on which the relevant extension method is invoked so in this case the list of employees stored in the employee list variable is passed into the filter method into this parameter automatically so if we look at the filter extension method we can see that this keyword precedes the definition of the first parameter the this keyword in this context is telling the c-sharp compiler that the
argument passed into this parameter is the object on which the relevant extension method is invoked so we have access to the argument passed into the first parameter automatically okay so the second parameter accepts a delegate object that points to a method that needs to be created on the calling client so this method that we'll create essentially tells the filter method how we want our list filtered so we are able to define this method in the calling client code through the use of a lambda expression a lambda expression is a concise way to
represent an anonymous method if we look at the definition of the relevant delegate parameter we need to define a method that accepts an argument of type t and returns a boolean value so the c-sharp compiler has enough information to infer that the intended type for type t is employee in this context we are calling the filter extension method on a strongly typed generic list the generic list is strongly typed with the employee user defined type so say we want to filter our employee list based on the value of each relevant
employee items is manager property we want to filter the list where we only want to return those employee records where is manager is true so we want to return all the records from our list where the relevant employees are managers so to achieve this we can pass in this lambda expression here we are telling the filter method how we want our list filtered let's write code to print the results to the console screen right let's run the code okay so we have no data ah
we of course need to populate our employee list with data so let's assign the value returned from data.get employees to the employees list variable right let's run the code great and you can see that only the employee records where the relevant is manager property value is set to true are returned to the calling client code great and we can of course inject the converse of this logic into our filter method through the relevant lambda expression like this so we are now saying we only want to bring back employees who are not managers let's run
the code great and for good measure let's modify our lambda expression so that the filter method only returns employees that earn less than 50 000 a year great and because we have used generics for our filter method we can call the filter method on a list of various c-sharp types including user-defined types so let's prove this and call our filter extension method on a list of departments let's filter the departments based on the department's short name so let's bring back the finance department and the human resources
department great let's bring back only those departments with ids greater than one so the point of this is to show you the flexibility that the combination of extension methods and lambda expressions create when writing the calling client code the combination of extension methods and lambda expressions not only provide this flexibility but at the same time ensure that the calling client code is clean and concise once we understand how extension methods and lambda expressions work they are incredibly powerful tools
so how do extension methods and lambda expressions work in relation to the topic of this video link language integrated query extension methods and lambda expressions are fundamental to how link is implemented in c sharp the enumerable class and the queryable class are two static classes that contain extension methods the enumerable class and the queryable class are both members of the system.
link namespace so to gain access to the extension methods provided through link we can simply include a using directive to the system.link namespace without including a using directive to the system.link namespace you can see that we are not able to access the where extension method provided by link to perform our filtering operation on a collection that implements the i enumerable interface so let's include the system.
link namespace we now have access to link's wear extension method so we can now replace our custom filter extension method with the wear link extension method like this we don't need to create our own filter extension methods to perform such queries on our data link has got us covered for this link also provides us with a sequel like query syntax
so for example if we wanted to produce a query result by joining selected fields from data selected from our collection of employee objects with selected fields or field in this case from data in our collection of department objects we can use link query syntax to perform our inner join operation on these two collections of data like this in the linq query we want to include the department long name field so that we can have a descriptive name for our department in our result set rather than displaying a result that only contains the
department id which is available in the employee type so we can achieve this result by using the join clause in a link query to perform our inner join on our collection of employee objects with our collection of department objects we have the department id property and the employee type so we can join using this department id property and the employee type to the id property which is a member of the department type so say we were to write the equivalent query using transact sql against the sql server database that contained an employee table with
the same data schema as our employee type and a department table that contains the same schema as our department type the transact sql query syntax would look something like this we are using an inner join to join data in an employee table with data in a department table we are able to make the join because the employee table contains the department id which can be joined in our query to the id of the department table so you can see the similarities and syntax between the transact sql syntax and the link query syntax the link query
is dealing with objects encapsulating the employee and department records the employee list collection is like the employee table and the department list is like the department table in this particular context we have a select clause a from clause and a join clause in the syntax for both the linq query and the transact sql query however the from clause in the linq query appears at the beginning of the query and the select clause in the linq query appears at the end of the query so there are differences in the ordering of the
clauses when comparing the syntax of the transact sql query with the syntax of the relevant link query an advantage of link is it can be leveraged in our c-sharp code to query data in a standardized way that is independent from the format of the underlying data source the data source could be a mongodb database a sql lite database a sql server database etc this will not affect the syntax of our link queries so the object layer provided by link can be used for abstracting our queries of the data from the underlying data source
and by using link we also have the added advantage of compile time strong typing and the type checking provided by the c-sharp compiler let me draw your attention to the select clause we are able to return the data as an ienumerable collection of anonymous types we are assigning the collection returned by the linq query to a variable preceded by the var keyword beginning with c-sharp version 3 variables that are declared at method scope can have an implicit type var through the use of the var keyword the c-sharp compiler is able to infer
the types included in the collection returned from the query so we are able to return a collection of objects that are of an anonymous type that we have defined directly within the link query anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first you can see how the use of anonymous types can provide the developer with flexibility and convenience when constructing relatively complex queries note that microsoft recommends using the
query syntax where possible as opposed to using relevant extension methods for the same purpose this is because of the readability advantage provided in the relevant query syntax there are however times where you'll need to use appropriate extension methods included within the link namespace because some functionality in link does not have a query syntax counterpart for example if we wanted to calculate the average salary for all employees we would need to use the average extension method like this the same applies if we wish to
query for the highest salary from a list of employee records we would need to use the max extension method like this this functionality cannot be performed through the use of query syntax but where possible query syntax is preferable due to the code readability advantage that this syntax provides i hope you've enjoyed this video which provides an introduction to link this video was created to help with the understanding of the fundamentals of link the advantages that link provides and how we are able to implement basic
link queries in code link provides us with an integration of query capabilities directly into the c-sharp language it is a very powerful technology that decouples query logic from relevant types of underlying data formats link provides a layer of abstraction that provides the developer with easy to implement syntax for querying collections of objects the relevant collection types must implement the iqueryable or generic iqueryable interface or the innumerable or generic ienumerable interface note that the iqueryable interface
inherits from the i enumerable interface and the generic i queryable interface inherits from both the i enumerable interface and the generic innumerable interface a suite of extension methods and query syntax are made available to c-sharp developers which provide flexibility when constructing powerful readable queries against data encapsulated within appropriate c-sharp collections this video is a basic introduction to leveraging link in the c-sharp language in the next tutorial we'll delve deeper into this subject matter
please consider subscribing for more content on advanced t-sharp concepts and much more and please ring the bell so that you'll be notified of future content released from this channel if you feel you've gained value from viewing this video please hit the like button it will be greatly appreciated please feel free to share any of my videos with anyone you feel may benefit from their content i'd like to thank those who have sent me such kind and thoughtful comments i really enjoy reading your comments so
please feel free to share your thoughts with me in the comments section the code created in this video is available on github a link to the relevant github repository is available below in the description thank you and take care [Music] [Music]
hey oh
