Abstraction in Object-Oriented Programming (OOP) is a way to hide complex implementation details and only expose the necessary and relevant information. 
In C#, abstraction is typically implemented using abstract classes or interfaces. 
These allow us to define a blueprint without providing the full implementation, 
leaving the specifics to be filled in by derived classes or implementing classes.

// Abstract class
public abstract class Animal
{
    // Abstract method (no implementation)
    public abstract void MakeSound();

    // Non-abstract method (common behavior)
    public void Sleep()
    {
        Console.WriteLine("Sleeping...");
    }
}

// Dog class inherits from Animal and provides implementation for MakeSound
public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
}

// Cat class inherits from Animal and provides implementation for MakeSound
public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Meow!");
    }
}

public class Program
{
    public static void Main()
    {
        // Creating instances of Dog and Cat
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        // Calling the abstract method MakeSound()
        myDog.MakeSound();  // Outputs: Woof!
        myCat.MakeSound();  // Outputs: Meow!

        // Calling the non-abstract method Sleep()
        myDog.Sleep();  // Outputs: Sleeping...
        myCat.Sleep();  // Outputs: Sleeping...
    }
}

Explanation:

    Abstract Class: 
    The Animal class is abstract, meaning it cannot be instantiated directly. 
    It provides an abstract method MakeSound() that has no implementation and forces derived classes (e.g., Dog and Cat) to implement this method.
    Non-Abstract Method: 
    The Sleep() method in the Animal class is a concrete method with an implementation, so it's shared by all derived classes.

In this example, the complex behavior of each animal's sound is abstracted away in the Animal class, while the specific implementation is left to the Dog and Cat classes.

// Interface
public interface IAnimal
{
    void MakeSound();  // Abstract method by default
    void Sleep();      // Abstract method by default
}

// Implementing the interface in Dog class
public class Dog : IAnimal
{
    public void MakeSound()
    {
        Console.WriteLine("Woof!");
    }

    public void Sleep()
    {
        Console.WriteLine("Dog is sleeping...");
    }
}

// Implementing the interface in Cat class
public class Cat : IAnimal
{
    public void MakeSound()
    {
        Console.WriteLine("Meow!");
    }

    public void Sleep()
    {
        Console.WriteLine("Cat is sleeping...");
    }
}

public class Program
{
    public static void Main()
    {
        // Creating instances using the interface
        IAnimal myDog = new Dog();
        IAnimal myCat = new Cat();

        // Calling interface methods
        myDog.MakeSound();  // Outputs: Woof!
        myDog.Sleep();      // Outputs: Dog is sleeping...

        myCat.MakeSound();  // Outputs: Meow!
        myCat.Sleep();      // Outputs: Cat is sleeping...
    }
}

Explanation:

    Interface: 
    The IAnimal interface contains method declarations, but no implementations. 
    It defines the contract that any class implementing it must follow by providing its own implementations of MakeSound() and Sleep().
    Implementation: 
    Both Dog and Cat classes implement the IAnimal interface and provide specific implementations for MakeSound() and Sleep().

In this case, the interface IAnimal abstracts away the specific animal behavior, and the classes that implement the interface provide the actual implementations.
Key Differences Between Abstract Class and Interface:

    Abstract Class: 
    Can have both abstract methods (without implementation) and concrete methods (with implementation).
    Interface: 
    Only contains method signatures (declarations), all methods are abstract by default. A class implementing the interface must provide an implementation for all methods.

Both approaches promote abstraction by hiding the complexity of method implementations while providing a blueprint for the behavior.




Interface :

In C#, an interface is a contract that defines a set of methods or properties that a class or struct must implement. 
Interfaces only define signatures of methods, properties, events, or indexers, without any actual implementation.
Classes that implement an interface must provide the concrete implementation of its members.

Key Characteristics of an Interface:
    All members of an interface are abstract (implicitly, so no need to use the abstract keyword).
    A class can implement multiple interfaces, even though it can inherit from only one class.
    Interfaces define "what" a class must do, but not "how" it does it.

public interface IAnimal
{
    void MakeSound();  // Interface method (no implementation)
    void Sleep();      // Another interface method
}

// Defining the interface
public interface IAnimal
{
    void MakeSound();  // Interface method with no body
    void Sleep();      // Another interface method with no body
}

// Implementing the interface in the Dog class
public class Dog : IAnimal
{
    public void MakeSound()
    {
        Console.WriteLine("Woof!");
    }

    public void Sleep()
    {
        Console.WriteLine("Dog is sleeping...");
    }
}

// Implementing the interface in the Cat class
public class Cat : IAnimal
{
    public void MakeSound()
    {
        Console.WriteLine("Meow!");
    }

    public void Sleep()
    {
        Console.WriteLine("Cat is sleeping...");
    }
}

public class Program
{
    public static void Main()
    {
        // Creating instances of Dog and Cat using the interface type
        IAnimal myDog = new Dog();
        IAnimal myCat = new Cat();

        // Calling methods defined in the interface
        myDog.MakeSound();  // Outputs: Woof!
        myDog.Sleep();      // Outputs: Dog is sleeping...

        myCat.MakeSound();  // Outputs: Meow!
        myCat.Sleep();      // Outputs: Cat is sleeping...
    }
}

Explanation:

    Interface Definition (IAnimal): The interface IAnimal defines two methods MakeSound() and Sleep() but provides no implementation.
    Dog and Cat Classes: Both Dog and Cat classes implement the IAnimal interface, 
    meaning they must provide concrete implementations for MakeSound() and Sleep().
    Polymorphism: We can create objects (myDog, myCat) using the IAnimal interface type. 
    The actual method that is executed depends on the runtime type (i.e., whether it's a Dog or a Cat).

Multiple Interface Implementation:
In C#, a class can implement multiple interfaces. This allows greater flexibility and modular design.

// First interface
public interface IAnimal
{
    void Eat();
}

// Second interface
public interface ICreature
{
    void Move();
}

// Class implementing both interfaces
public class Bird : IAnimal, ICreature
{
    public void Eat()
    {
        Console.WriteLine("Bird is eating...");
    }

    public void Move()
    {
        Console.WriteLine("Bird is flying...");
    }
}

public class Program
{
    public static void Main()
    {
        Bird myBird = new Bird();
        myBird.Eat();   // Outputs: Bird is eating...
        myBird.Move();  // Outputs: Bird is flying...
    }
}

Benefits of Using Interfaces:

    Multiple Inheritance: 
    C# does not support multiple inheritance for classes, but interfaces provide a way to implement multiple behaviors.
    Loose Coupling: 
    By depending on interfaces rather than specific classes, you can make your code more flexible and less tightly coupled to specific implementations.
    Polymorphism: 
    Interfaces support polymorphic behavior by allowing the use of interface types to refer to objects of classes that implement those interfaces.

Interfaces are a powerful feature of C# that promote flexible and reusable code, allowing you to design systems that are easy to extend and maintain.S


















----------------------------------------------------------------------------


important aspect of object-oriented programming is abstraction 
in c-sharp abstracting general rules and functionality before implementing functional code logic
detail when constructing an application can be achieved through the use of abstract classes and interfaces 

abstraction 
essentially involves the separation of design implementation from concrete code logical implementation 
so interfaces and abstract classes can be used in c-sharp to implement the design of an application and code the design on its own 
however is meaningless without the appropriate functional logical code

implementation detail abstracting codes so that types are loosely coupled and provide a flexible and extensible design 
for your applications prior 

let's explore c-sharp interfaces through a code example [Music] [Applause] let's first create a project using the console app net core project template 
I'm going to name this project interfaces tutorial so the theme of this code example will relate to a construction
company please remember to like subscribe share comment to support the channel it will be greatly
appreciated let's start with a basic class named employee and let's add some readwrite Auto implemented properties to the employee class notice that these properties all have both get inset sections which means the calling code can both read values from these properties as well as assign values to these properties so as you can see the get basic information member is a method the function of this method is to serialize certain property data and return this data to the calling code so let's test the employee class by writing
code in the main method to instantiate an object from the employee class and assign appropriate values to the properties contained within the employee class let's then write code to call the get basic information method and write the returned string value to the console screen let's run the code and you can see the property values are written to the screen and the format that was coded in the get basic information method okay so in this application we want to include many types of employees that you may find in
a construction company we can encapsulate the employee types within appropriate classes based on the employees respective roles for example we could have a class named crane operator and a class named electrician to encapsulate data and behavior for each of these types of employees but there's certain common data and behaviors that can be applied to all employees regardless of the employees respective roles so how can we ensure that our application reuses functionality across multiple employee types well we can start by abstracting a
common interface for all employees within the construction company and code this can be achieved by creating an interface so creating an interface and code is very similar to creating a class but instead of the class keyword we use the interface keyword and notice that no code implementation is included for any of the interface members the interface only provides the property definitions and method signatures and also notice that no access modifiers are applied to the property and method definitions this is because by default interface members
are all public so the naming convention for an interface is that a capital I should be included at the beginning of the interface name in this example our interface name is AI employee the AI prefix is capitalized signifying that the c-sharp type is an interface and the subsequent part of the name contains more descriptive text about the nature of the interface which also begins with a capital letter in this case capital e for employee when an interface is implemented by a class or struct the class or struct is
obligated to implement code logic for each of the members included in the interface so you can think of an interface as a contract that must be fulfilled by any class or struct that implements it a developer can include the following member types in an interface methods properties indexes and events in this course we have covered methods properties and indexes events will be discussed in an upcoming tutorial in this tutorial we'll focus on two of these member types namely properties and methods in the tutorial
on c-sharp inheritance we discussed that in C sharp and dotnet only single inheritance is permitted ie a class cannot directly inherit from more than one class at a time this rule does not apply for a class or struct implementing interfaces the class will struct can implement code for multiple interfaces note that an interface is able to inherit from another interface if for example Class A implements code for interface ia and interface IA inherits from interface IB plus a must implement code for all the members of both
interface ia and interface IB so as stated in the beginning of this tutorial and interface contains the design structure for those classes or structs that implement code for the interface an interface on its own is meaningless let's prove this let's try to instantiate an object from the I employee interface the c-sharp compiler immediately Flags an error stating cannot create an instance of the abstract class or interface I employee an interface only becomes meaningful when a class will struct implements code
for each of the interface members the interface provides a design abstraction that can be applied to multiple classes or structs the interface enforces a rule that all classes or structs that implements an interface must implement code logic for all of the members contained within the relevant interface so in order to make our I employee interface meaningful let's implement code for its members in the employee class so let's comment out the current members of the employee class let's then write the code whereby the employee
class implements the AI employee interface and you can see that the code is similar to when a class inherits from another class a colon follows the class's name and this is followed by the name of the interface and now red squiggly lines appear under the I employee interface name and the class definition for the employee class and if we hover our mouse pointer over the red squiggly line the c-sharp compiler presents us with a message that lists all the members of the AI employee interface that we must implement code
for in the employee class so let's click show potential fixes then implement interface as you can see Visual Studio has provided default implementations in the employee class for each of the members of the AI employee interface each of the current implementations provided by Visual Studio force are not implemented runtime exception to be thrown so let's create auto implemented properties for each of the property definitions contained in the AI employee class we could implement code for each of the get or set methods of any of
these properties for example if we wanted to ensure that a string value assigned to the job title property is valid where it cannot exceed a maximum length of 50 characters and must not be less than 2 characters in length this can be implemented in the set method thus tutorials focused on interfaces so I'm going to leave these properties as Auto implemented properties let's move on to the get basic information method let's implement code so that the get basic information method returns a string in a custom format the string
contains values for the ID job title first name and last name properties serialized whereby each property is represented on its own line with an appropriate property label followed by a colon preceding the value currently as to the relevant property so we've implemented custom code for the get basic information method another class implementing the I employee interface could implement this method differently and this will be demonstrated a bit later in this tutorial but each class that implements code for
this method is constrained by the interface definition for this method where the implementing method must be named get basic information the method must not accept any parameters and must return a string value so let's go to the main method and use the I employee type to define a variable named amp and then instantiate an object from the employee class using the new keyword note that you can say the employee class is of type I employee let's run the code and that is an expected result the employee classes of type I employee
because it implements the members of the I employee interface as demonstrated earlier you cannot instantiate an object directly from an interface but you can't instantiate an object from a class that implements the relevant interface so let's go more into the significance of abstracting functionality that can be applied to multiple types let's create another class and call this class crane operator this class represents an employee whose role in the construction company is that of a crane operator let's go to our main
method and test the operator class and we can literally just replace the code new employee with new crane operator because the crane operator class also implements the AI employee interface which means they have exactly the same type definition the crane operator class and the employee class are of type AI employee so let's run the code and this is an expected result so let's say we want to extend the crane operator class by adding a new method this public method returns an integer and accepts no parameters the methods function is to
return the number of full years that the employee has worked at the construction company we can calculate the full years worked by an employee by simply finding the difference in years between the current date and the value assigned to the join date property which as the name implies refers to the date when the employee joined the construction company I'm not going to go into the detail of how this code in the get full years worked method works as I want to maintain the focus on c-sharp interfaces so let's test this functionality in our
main method and the difference in the number of years between the time when this video was recorded and the employees joined date which is the 12th of April 2011 is eight years great so let's create a class to represent another type of employee that works for the construction company namely an electrician let's implement code for each of the members of the I employee interface for the electrician class let's go to the main method and test the
code and notice how when we define the M Priya ball that we need to define it as The Electrician class and not the I employee interface this is because we want to call the get four years worked method on the amp object and the I employee type does not contain a definition for the get full years worked method so we need to define a variable with the electrician type in order to see the get four years worked method in our code editor right let's run the code and this works fine but our code implementation is not ideal we are
repeating the same implementation for the gate for years worked method and both the crane operator class and the electrician class how can we ensure that this repeated code is only written once which is a key object of an object-oriented programming so to achieve this we can make the employee class that we created earlier into an abstract class we can implement the code for the gate for years worked method in the employee abstract class which will mean this code can be accessed from any class that inherits from the employee class
you so we can now change the crane operator class on the electrician class to inherit from the employee abstract class now that the crane operates a class in the electrician class both inherit from the employee abstract class we can get rid of the code implementations that these classes are implementing for the I employee interface this is because code implementations for members of the I employee interface are now consolidated in the employee abstract class and let's ensure that the get us worked method
definition is added to the I employee interface and we are now able to change the Declaration code and instantiation code to my employee amp equals to new crane operator the get full year's work method is in one place and is available to any class that implements the I employee interface we have made the employee class an abstract class that implements the I employee interface this means that future classes representing employee types added to this application can simply inherit from the employee abstract class to ensure a
consistent design across all employee types functionality common to all employees can be consolidated in one place ie the employee abstract class if code is modified in the employee abstract class this modification will automatically affect all the other classes that inherit from the employee abstract class so let's create another class representing another employee at the construction company the drywall installer as you can see the code is clean and easy to implement because we have abstracted common functionality for
an employee through the use of an interface and an abstract class so let's test our new drywall installer class and the result is as expected we are now able to create employee classes by implementing a small amount of code and they will automatically inherit the common functionality implemented in the employee abstract class and the structure established in the I employee interface let's create two employee classes representative of employees that are at the managerial level in the construction company
so let's first create a class representing an employee whose role is that of a project manager let's say that all managers in the construction company have their own offices and each manager has a secretary so a manager is also an employee but requires additional data the project manager is a manager but is also an employee so the project manager must inherit from the employee abstract class and then we can extend the project manager class by adding the additional properties that are unique to employees
who also managers so let's reflect this by adding two properties to the project manager class let's add the office ID property which represents an office location this property is of the string datatype let's add the secretary ID property this property contains the ID of an employee so this property will be of the integer datatype let's add a class representing another manager this class represents the position of Safety Manager let's name this class Safety Manager the Safety Manager is of course
an employee so it must inherit from the employee abstract class let's add the two additional manager related properties namely the office ID property and the secretary ID property and it is clear we are repeating these two properties for employee classes who are also managers so we can abstract these two properties by creating an interface so let's create an interface named I manager as discussed in previous tutorials in c-sharp it is not possible for a class or struct to inherit from multiple classes at one time but in
c-sharp a class is able to inherit from one class but in addition to this is able to implement as many interfaces as is deemed necessary so our safety manager and project manager classes are able to inherit from the employee abstract class as well as implements the AI manager interface so we want to include two new properties office ID and secretary ID and the information output it to the console screen as part of the serialized string returned in the get basic information method that has been implemented in the employee abstract
class because the get basic information method is a virtual method we can override this method we can use the base keyword to call the get basic information method in the employee base class and we can then concatenate the values of the office ID and secretary ID properties to the string returned by the get basic information method in the employee base class the code and the overridden version of the get basic information method will return standard employee property values as well as standard managerial related properties
to calling code so we don't want to repeat this code implemented for the over and get basic information method for all managerial related classes so we can facilitate the reuse of this functionality by abstracting common manager related functionality into an abstract class let's call this new class manager so the manager class will be an abstract class that inherits from the employee class as well as implements the eye manager interface and we must implement all members of the eye manager interface because as discussed when you
implement an interface on a class you are imposing a rule on the relevant class that all members of the relevant interface must be appropriately implemented and now any manager related class that is added to this application in the future can from the manager abstract class which encapsulates the common functionality required for manager related classes okay so let's write code in our main method to test the manager class let's run the code and you can see that both functionality in the employee class that
implements the I employee interface and functionality in the manager class that implements the I manager interface is utilized by the calling code on the project manager object in our main method and for good measure let's also test the safety manager class you great so let's go up a level in the management hierarchy and create a class named chief executive officer so although the chief executive officer is at the top of the employee hierarchy the chief executive officer is also both a manager and an employee unlike a
manager and an employee let's say the chief executive officer has a personal assistant and we want to extend the chief executive officer class by adding a property that will store the ID of the chief executive officers personal assistant so we could have the chief executive officer implements the AI employee and AI manager interfaces and then extend the functionality for the chief executive officer plus by adding a property that stores an ID reference for the chief executive officers personal assistant but we have already
encapsulated functionality for managers and employees in the manager abstract class so in order for the chief executive officer class to inherit functionality for a manager and an employee we only need to write code for the chief executive officer to inherit from the manager abstract class we can then extend the functionality of the chief executive officer class by adding the personal assistant ID property let's create an interface representing functionality unique to a chief executive officer so let's create an interface named eye
chief executive officer and add the personal assistant property definition to the eye chief executive officer interface let's then write codes that the chief executive officer class implements the eye chief executive officer interface and then of course let's fulfill the contract whereby we must implement the members of the eye chief executive officer interface in this case there is only one property member to implement we can then override the get basic information method and concatenate the values stored in the
personal assistant property to the string value returned from the manager abstract classes implementation of the get basic information method let's write code in the main method to test the chief executive officer class you and this demonstrates that the functionality in the chief executive officer manager and employee classes is working as expected you and you can see how we've been able to reuse common functionality across multiple types as highlights the advantage of appropriately abstracting common functionality the code is clean
easy to maintain and reuse so now that we have a basic structure created for our application through the utilization of classes abstract classes and interfaces let's create a more substantial code example to test this code infrastructure so firstly let's create a method in our program class that will be called in the main method and we'll create an in-memory store of employees so let's name this method seed data it does not return a value so we use the void keyword to signify this the seed data method must be static so that
it can be called directly from the static main method the seed data method contains one parameter named employees this parameter is a strongly generic list this is made clear in the parameters type definition where the list type definition code for the employees parameter includes the AI employee type within greater than and less than symbols we are about to demonstrate how using the AI employee interface to strongly type the employees list enables the loose coupling of the list with all of our employee types it
is better to use abstractions for type definitions if for example the employees list was strongly typed as the chief executive officer tab we would only be able to store objects derived from the chief executive officer class in the employees list this would an effect tightly couple the employees list with the chief executive officer class by using the AI employee abstraction to strongly type the employees list we have created flexibility in our design and room for extensibility we have loosely coupled the employees list with our
employee objects so let's create an object derived from the chief executive officer class let's assign appropriate values to the objects properties and then add the object to the employees generic list let's create an object arrived the project manager class let's assign appropriate properties to the project manager object and then add this object to the employees generic list let's create an object derived from the safety manager class and repeat the process so let's create an object derived from
the Prater class and let's say there's a requirement to extend the functionality of the crane operator class so the requirement is that for certain jobs that a crane operators assigned a certain percentage is added to the crane operators salary let's say that the justification for this increase in salary is that many of the crane operators tasks are more dangerous than the tasks assigned to employees that occupy other positions so let's extend the crane operator class by adding a method named get danger pay increase and
to keep things simple this method will return a decimal value representing a 4% increase so now let's make the annual salary property in the employees abstract class a virtual property you and then let's override the annual salary property and the crane operator class so that we can add the danger pay increase amount to the crane operator salary so we have just demonstrated here that when an interface member is implemented within a class that the implemented member can be written to include the virtual keyword meaning that
derived classes can override the relevant member and let's include the annual salary property value as part of the string value returned by the get basic information method note that this modification of the get basic information methods returned string will propagate to any derived class that inherits from the employee abstract class so now the annual salary property will be included as part of an employee's basic information for all employees in this application we have modified the code in one place and this
modification will affect multiple implementations across many classes this highlights the benefit of abstracting common functionality and facilitating code reuse okay so let's assign appropriate values for the properties of our crane operator object to our seed data method let's then create two more objects both of the electrician type and add these objects to the employees generic list note our C sharp allows us to create a multitude of object types and because all of these types implements the I employee interface we are able to store
these objects in a list that is strongly typed as the I employee type so we are able to do this because these objects are derived from classes that implement the I employee interface and this enables employee objects of taps that may have evolved quite differently for example an object of type crane operator and an object of type chief executive officer to be added to the strongly typed employees to narrate list just to emphasize that this is possible because the chief executive officer class and the crane operator class both implements
the I employee interface these classes are both of the I employee type so let's create another method in the program class that basically implements code to call the get basic information method on any object derived from a class that implements the I employee interface and writes the employee's basic information to the console screen this method is named write employee information to screen does not return a value and accepts one argument of type I employee so this method is able for example to accept objects of type crane operator
objects of type Safety Manager and objects of type chief executive officer basically any object that implements the I employee interface we have loosely coupled this method from our employee objects by defining the employee parameter as the I employee type we have achieved this loose coupling effect using an abstraction to define the employee parameter here we can see an example of an interface being applied to facilitate code reuse and let's write a method that outputs a header to the screen let's call this method from our
write employee information to screen method let's then create another method and the program class that facilitates a basic navigation mechanism so that the user can navigate through the employees list using the right and left arrow keys you you so let's call the code from the main method just a reminder that all code created in this tutorial can be downloaded from github please see a link to the appropriate repository below in the description right let's run the code let's navigate through the employee
information using the left and right arrow keys and notice that the additional danger pay has been added to the crane operators salary the annual salary for the crane operator was assigned a value of 50,000 the overridden annual salary property and the crane operator class as an additional 4% to the value initially assigned to this annual salary property for the crane operator so the annual salary displayed to the screen for the crane operators 52,000 which is the correct amount great so just to summarize what we have discussed and
demonstrated in the first part of this tutorial on c-sharp interfaces 

we discussed that an interface contains definitions for a group of related functionalities that a class or a struct can implement we discussed that by using interface as you can for example include behavior from multiple sources in a class interfaces should not contain code implementations however note that in the next part of this tutorial we'll discuss that from C sharp vision 8 and onwards default code can now be implemented for interface members this default
implementation functionality was introduced in c-sharp version 8 so their newly added interface members do not break existing client code interfaces can represent a calling client code what the classes and structs that implement their members are able to do more than one interface at a time can be implemented by a class or struct this is unlike inheritance for classes where only single inheritance is allowed and interfaces like a contract it is an agreement that when class or struct implements an interface all members of
the interface must be implemented and the relevant class will strike an interface can inherit from other interfaces if for example a class implements an interface that inherits from other interfaces that class must implement code for all members ie for the interface included in the class's definition and the interfaces from which the interface included in the class's definition inherits the c-sharp member types that can be included in interfaces or methods properties indexes and events in part two of this tutorial
we'll discuss the new functionality added in c-sharp version 8 where default implementations can now be included in interfaces so in this tutorial we looked at implicitly implemented interfaces and the next part of this tutorial will discuss explicitly implemented interfaces we'll continue with the example demonstrated in this tutorial and demonstrate how to implement interface members explicitly please like subscribe share and comment to support the channel that will be greatly appreciated and please ring the bells
that you can be notified of future content which will be coming soon as always all code in this tutorial can be downloaded from github a link to the relevant repository has been included below in the description thank you and take care [Music] [Music] you


---------------------------------------------------

I want to demonstrate a new feature added in c-sharp version 8 where interfaces can include default implementations earlier in this tutorial we discussed that with interface code implementations for interface members was not possible this has changed in c-sharp version 8 where default implementations are now possible for members of interfaces if you wish to upgrade to c-sharp version 8 one way to do this is to upgrade your version of the.net core SDK to 3.
0 and install the latest official release version of Visual Studio 2019 if you haven't already installed Visual Studio 2019 I have included a link below in the description to a video created for this channel that can help guide you with this installation process if you have already installed Visual Studio 2019 but you have not yet installed the latest version of the software you can use Visual Studio installer for this purpose I've included links below in the description to URLs that contain content that can help you with the subgrade so
in order to demonstrate this new default implementation functionality for interfaces in c-sharp let's say that we have released a version of this code to clients and now we wish to include additional functionality for a subsequent release more specifically let's say that we wish to add a new method that will retrieve additional information from an employee's data we already have the get basic information method for retrieving basic information for employees so let's create a method name to get additional information and
you can see that if we add a method definition forget additional information to the I employee interface that this breaks our application because we are violating the rules and forced by the c-shell compiler whereby a class that implements an interface must implement code for all its members so if we hover our mouse pointers over the red squiggly line presented under the I employee text in the employee class definition we can see that C sharp has presented us with an error message stating employee does not implement
interface I employee dot get additional information so let's say for the moment we want to include the new get additional information method in the I employee interface but we don't yet know which additional information we wish to return to the calling client so we are able to include a default implementation and the I employee interface like this and now we are able to compile the let's say that for now we wish to return the employees join date and gender property values from the get additional
information method so if a calling client calls the get additional information method like this the default code we have just implemented in the I employee interface will be executed this will of course apply to any class in our application that implements the I employee interface let's prove this by running the code and you can now see that the joint date and gender property values relating to all the employee objects is now included when traversing the employees generic list using the right and left arrow keys
so the default implementation functionality for interfaces provided to us in c-sharp version 8 allows us to add a member to the AI employee interface without breaking existing code and let's say that the requirement for their get additional information method has now been firmly defined we can now implement code for this requirement by implementing code for the get additional information method in the employee class ie the class that implements the AI employee interface we can do this by implementing code for an interface
member in the usual way like this so say the requirement is that the join date and the gender property values are okay as temporary defaults but we want our implementation to return the highest qualification property value you okay let's run the code and you can see that the highest qualification property value is now included in the output rather than the joint date and gender property values so let's prove that see shop versions prior to version 8 do not support default member implementations for interfaces so if I right-click on
the property node in the solution Explorer window and click the property menu item then on the application screen we changed the target framework to the previous version of the dotnet core runtime installed on this PC so I'll change the version of the.net core runtime for this project to dotnet core version 2.
2 the effect of this change is that version 8 of the c-sharp language will not be supported for this project and now you can see that the c-sharp compiler is flagging an error if we hover our mouse pointers over the red squiggly line under the get additional information default implementation of the I employee interface you can see a compile-time error is presented and this message states feature default interface implementation is not available in C sharp vision 7.
3 please use language version 8.0 or later target runtime doesn't support default interface implementation so I think that message is pretty clear riots all changed the dotnet core runtime version backed net core version 3.0 and you can see that the default implementation for the get additional information method is once again accepted by the c-sharp compiler because c sharp vision 8 is now supported for this project so up until now we have focused on implicit implementations for interface members a developer is also able to create
explicit implementations for interface members let's create an example to explore what is meant by an explicit implementation of interface members and how explicit of limitations for interface members can be useful so in this tutorial we have created our classes and its faces manually but we are able to generate code that serves as a starting point for classes and interfaces through appropriate templates provided by Visual Studio so to add an interface in this way let's right-click the property node in our
solution Explorer window let's then select the add a new item menu item we are then presented with the add new item dialog box let's select the list item marked interface let's give our new interface a name we'll call this interface I apartment and there let's click the Add button and the interface file which contains the basic code for an interface structure is generated for us by visual studio so let's create a readwrite property definition of the integer data type named ID let's add
another property definition which represents the floor number where the apartment is situated and let's add a readwrite property definition which when implemented by a derived class will store the size of the apartment measured in square meters this property is of the double dates tab and has named size and square meters so let's add another two interfaces the first interface is named I dimension metric it contains a method definition for a method that returns a value of the double date stuck this method is named get size so the second
interface is named I dimension Imperial and notice this interface also contains a definition for a method name to get size that returns a value of type double both the I dimension imperial interface and the i dimension metric interface contain definitions for a method named get size and their method signatures are identical so let's add a class and name this class apartment and let's write code that implements the three in two phases that we just created namely the AI apartment interface the eye dimension metric interface and the eye
dimension imperial interface let's then implement the members for the AI apartment interface implicitly like this now let's explicitly implement the gates method for the eye dimension metric interface so if we hover our mouse pointers over the red squiggly line under the eye dimension metric text in the apartment classes class definition then click show potential fixes then click the option marked implement interface explicitly Visual Studio generates an explicit implementation for the get sales member contained in the
eye dimension metric interface and now let's follow the same steps for the eye dimension imperial interface and you can see that we now have two explicit implementations for the gate size method one implementation for the get size member contained in the eye dimension metric interface and one for the get sized member and the eye dimension imperial interface you can see that there is a very obvious difference between these two method definitions the one get size method definition has i dimension metric dot prefixing its
method name in its method definition the other get size method definition has eye dimension imperial dot prefixing its method name in its method definition both gets ours methods do not contain any access modifiers so you can immediately see the difference in signatures of the get size methods that are explicitly implemented and the other members of the apartment class that are implicitly implemented so you may have guessed this but the get size method that implements the get Czar's member of the our dimension metric interface will
return a size represented as a metric value ie measured in square meters so this method will simply return the value stored in the size and square meters property no additional calculation and this method is needed and the getsize method that implements the get sales member in the eye dimension imperial interface we need to perform a mathematical calculation we do this by multiplying the values stored in the size and square meters property by ten point seven four six this will give us the equivalent size measured in
square feet we can then round off the result to two decimal places by using C sharps in built math classes round method like this so let's look at how to write code to use explicitly implements that interface members from calling client code let's go to our main method let's write code to create an apartment object so if we wish to execute the code for the apartment classes getsize method that is an explicit implementation of the I Imperial interfaces get sized method definition we need to define an
object variable of type I dimension Imperial and assign the apartment object to this variable and if we wish to execute code for the apartment classes get SARS method that is an explicit implementation of the I dimension metric interfaces get SARS method definition we need to define an object variable of type I dimension metric and assign the apartment object to this variable let's write the code that writes the return values of these two methods to the console screen you and you can see presented to us on the
console screen the size of the apartment represented by the Imperial value in square feet and on the following line the metric value equivalent in square meters excellent 


we've discussed the rules associated with interfaces and how to apply them in code to implement a structural design for our applications we've discussed and demonstrated how interfaces and abstract classes can be applied in code to abstract common functionality that can be used by multiple types we've discussed and demonstrated how
abstraction in object-oriented programming can be applied to ensure common functionality is implemented just once in code for an application we demonstrated that interfaces can only contain member definitions and not code implementations for those members however a new feature was released with c-sharp version 8 which allows developers the ability to implement default implementations for interface members this feature provides the benefit of adding new members to interfaces without breaking existing code we looked at the implicit
implementation of interfaces and the explicit implementation of interfaces we demonstrated through a code example how to consume explicitly implemented interface members from client code please like subscribe share comments to support the channel it will be greatly appreciated and please ring the bells so you can be notified of future content which will be coming soon as always the code created for this tutorial can be downloaded from github a link to the appropriate repository has been included below in the description in the next
tutorial which will be the twenty-first part of the c-sharp for beginners course will focus on exception handling thank you and take care [Music] you
